(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{79:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return s})),a.d(t,"metadata",(function(){return c})),a.d(t,"rightToc",(function(){return i})),a.d(t,"default",(function(){return b}));var n=a(3),r=a(7),o=(a(0),a(94)),s={id:"stacks",title:"Stacks"},c={unversionedId:"stacks",id:"stacks",isDocsHomePage:!1,title:"Stacks",description:"Ingress stack",source:"@site/docs/stacks.md",slug:"/stacks",permalink:"/vkpr-docs/docs/next/stacks",editUrl:"https://github.com/vertigobr/vkpr/edit/docs/docs/stacks.md",version:"current",sidebar:"docs",previous:{title:"Introduction",permalink:"/vkpr-docs/docs/next/"},next:{title:"Roadmap",permalink:"/vkpr-docs/docs/next/roadmap"}},i=[{value:"Ingress stack",id:"ingress-stack",children:[{value:"NGINX Ingress Controller",id:"nginx-ingress-controller",children:[]},{value:"ExternalDNS",id:"externaldns",children:[]}]},{value:"Logging stack",id:"logging-stack",children:[{value:"Loki",id:"loki",children:[]}]},{value:"Monitoring stack",id:"monitoring-stack",children:[{value:"Prometheus Operator",id:"prometheus-operator",children:[]}]},{value:"Security stack",id:"security-stack",children:[{value:"cert-manager",id:"cert-manager",children:[]},{value:"Vault",id:"vault",children:[]},{value:"Keycloak",id:"keycloak",children:[]}]},{value:"Backup stack",id:"backup-stack",children:[{value:"Velero",id:"velero",children:[]}]}],l={rightToc:i};function b(e){var t=e.components,a=Object(r.a)(e,["components"]);return Object(o.b)("wrapper",Object(n.a)({},l,a,{components:t,mdxType:"MDXLayout"}),Object(o.b)("h2",{id:"ingress-stack"},"Ingress stack"),Object(o.b)("h3",{id:"nginx-ingress-controller"},"NGINX Ingress Controller"),Object(o.b)("p",null,Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/kubernetes/ingress-nginx"}),"ingress-nginx")," is an Ingress controller for Kubernetes using NGINX as a reverse proxy and load balancer."),Object(o.b)("p",null,"Ingress exposes HTTP and HTTPS routes from outside the cluster to services within the cluster. An Ingress resource supports exposing services and configuring TLS termination for each exposed host name."),Object(o.b)("h4",{id:"implementation"},"Implementation"),Object(o.b)("p",null,"By default the ",Object(o.b)("strong",{parentName:"p"},"NGINX Ingress Controller")," is enabled in ",Object(o.b)("em",{parentName:"p"},"VKPR")," installation. An example of configuration :"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-yaml"}),"nginx-ingress:\n  enabled: true\n  controller:\n    publishService:\n      enabled: true\n    autoscaling:\n      enabled: true\n      minReplicas: 1\n      maxReplicas: 3\n")),Object(o.b)("p",null,"To see more configurations, access the ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/helm/charts/tree/master/stable/nginx-ingress#configuration"}),"documentation"),". "),Object(o.b)("h3",{id:"externaldns"},"ExternalDNS"),Object(o.b)("p",null,Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/kubernetes-sigs/external-dns"}),"ExternalDNS")," is a Kubernetes addon that configures public DNS servers with information about exposed Kubernetes services to make them discoverable."),Object(o.b)("p",null,"Inspired by ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/kubernetes/dns"}),"Kubernetes DNS"),", Kubernetes' cluster-internal DNS server, ExternalDNS makes Kubernetes resources discoverable via public DNS servers. Like KubeDNS, it retrieves a list of resources (Services, Ingresses, etc.) from the ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://kubernetes.io/docs/concepts/overview/kubernetes-api/"}),"Kubernetes API")," to determine a desired list of DNS records. Unlike KubeDNS, however, it's not a DNS server itself, but merely configures other DNS providers accordingly\u2014e.g. ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://aws.amazon.com/route53/"}),"AWS Route 53")," or ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://cloud.google.com/dns/docs/"}),"Google Cloud DNS"),"."),Object(o.b)("h4",{id:"implementation-1"},"Implementation"),Object(o.b)("p",null,"By default the ",Object(o.b)("strong",{parentName:"p"},"ExternalDNS")," is disabled in ",Object(o.b)("em",{parentName:"p"},"VKPR")," installation. An example of configuration:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-yaml"}),'external-dns:\n  enabled: true\n  rbac:\n    create: true\n  sources:\n    - ingress\n    - service\n  provider: digitalocean\n  interval: "1m"\n')),Object(o.b)("p",null,"To see more configurations, access the ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/bitnami/charts/tree/master/bitnami/external-dns#parameters"}),"documentation"),". "),Object(o.b)("h2",{id:"logging-stack"},"Logging stack"),Object(o.b)("h3",{id:"loki"},"Loki"),Object(o.b)("p",null,Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/grafana/loki"}),"Loki")," is a horizontally-scalable, highly-available, multi-tenant log aggregation system inspired by ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://prometheus.io/"}),"Prometheus"),". It is designed to be very cost effective and easy to operate. It does not index logs content, but rather a set of labels for each log stream."),Object(o.b)("h4",{id:"implementation-2"},"Implementation"),Object(o.b)("p",null,"By default the ",Object(o.b)("strong",{parentName:"p"},"Loki")," is enabled in ",Object(o.b)("em",{parentName:"p"},"VKPR")," installation. An example of configuration:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-yaml"}),"loki-stack:\n  enabled: true\n  serviceScheme: https\n")),Object(o.b)("p",null,"To see more configurations, access the ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/grafana/loki/tree/master/production/helm"}),"documentation"),"."),Object(o.b)("h2",{id:"monitoring-stack"},"Monitoring stack"),Object(o.b)("h3",{id:"prometheus-operator"},"Prometheus Operator"),Object(o.b)("p",null,Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/coreos/prometheus-operator"}),"Prometheus Operator")," provides Kubernetes native deployment and management of ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://prometheus.io/"}),"Prometheus")," and related monitoring components. The purpose of this project is to simplify and automate the configuration of a Prometheus based monitoring stack for Kubernetes clusters."),Object(o.b)("p",null,"Prometheus Operator contains the following modules:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},Object(o.b)("strong",{parentName:"p"},Object(o.b)("a",Object(n.a)({parentName:"strong"},{href:"https://github.com/grafana/grafana"}),"Grafana"))," allows you to query, visualize, alert on and understand your metrics no matter where they are stored.")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},Object(o.b)("strong",{parentName:"p"},Object(o.b)("a",Object(n.a)({parentName:"strong"},{href:"https://prometheus.io/"}),"Prometheus"))," scrapes metrics from instrumented jobs, either directly or via an intermediary push gateway for short-lived jobs. It stores all scraped samples locally and runs rules over this data to either aggregate and record new time series from existing data or generate alerts.")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},Object(o.b)("strong",{parentName:"p"},Object(o.b)("a",Object(n.a)({parentName:"strong"},{href:"https://github.com/prometheus/alertmanager"}),"Alertmanager"))," handles alerts sent by client applications such as the Prometheus server. It takes care of deduplicating, grouping, and routing them to the correct receiver integrations such as email, PagerDuty, or OpsGenie. It also takes care of silencing and inhibition of alerts."))),Object(o.b)("h4",{id:"implementation-3"},"Implementation"),Object(o.b)("p",null,"By default the ",Object(o.b)("strong",{parentName:"p"},"Prometheus Operator")," is enabled in ",Object(o.b)("em",{parentName:"p"},"VKPR")," installation. An example of configuration:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-yaml"}),'prometheus-operator:\n  enabled: true\n  prometheusOperator:\n    createCustomResource: false\n  grafana:\n    adminPassword: "password"\n    ingress:\n      enabled: true\n      annotations:\n        kubernetes.io/ingress.class: nginx\n        kubernetes.io/tls-acme: "true"\n      hosts: ["grafana.whoami.com"]\n')),Object(o.b)("p",null,"To see more configurations, access the ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/helm/charts/tree/master/stable/prometheus-operator#general"}),"documentation"),"."),Object(o.b)("h2",{id:"security-stack"},"Security stack"),Object(o.b)("h3",{id:"cert-manager"},"cert-manager"),Object(o.b)("p",null,Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/jetstack/cert-manager"}),"cert-manager")," is a Kubernetes addon to automate the management and issuance of TLS certificates from various issuing sources."),Object(o.b)("p",null,"It will ensure certificates are valid and up to date periodically, and attempt to renew certificates at an appropriate time before expiry."),Object(o.b)("h4",{id:"implementation-4"},"Implementation"),Object(o.b)("p",null,"By default the ",Object(o.b)("strong",{parentName:"p"},"cert-manager")," is disabled in ",Object(o.b)("em",{parentName:"p"},"VKPR")," installation. An example of configuration:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-yaml"}),"cert-manager:\n  enabled: true\n  ingressShim:\n    defaultIssuerName: letsencrypt-production\n    defaultIssuerKind: ClusterIssuer\n    defaultIssuerGroup: cert-manager.io\n")),Object(o.b)("p",null,"To see more configurations, access the ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/jetstack/cert-manager/blob/master/deploy/charts/cert-manager/README.template.md#configuration"}),"documentation"),"."),Object(o.b)("h3",{id:"vault"},"Vault"),Object(o.b)("p",null,Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/hashicorp/vault"}),"Vault")," is a tool for securely accessing secrets. A secret is anything that you want to tightly control access to, such as API keys, passwords, certificates, and more. Vault provides a unified interface to any secret, while providing tight access control and recording a detailed audit log."),Object(o.b)("p",null,"A modern system requires access to a multitude of secrets: database credentials, API keys for external services, credentials for service-oriented architecture communication, etc. Understanding who is accessing what secrets is already very difficult and platform-specific. Adding on key rolling, secure storage, and detailed audit logs is almost impossible without a custom solution. "),Object(o.b)("h4",{id:"implementation-5"},"Implementation"),Object(o.b)("p",null,"By default the ",Object(o.b)("strong",{parentName:"p"},"Vault")," is disabled in ",Object(o.b)("em",{parentName:"p"},"VKPR")," installation. An example of configuration:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-yaml"}),"vault:\n  enabled: true\n  server:\n    ha:\n      enabled: true\n      raft:\n        enabled: true\n")),Object(o.b)("p",null,"To see more configurations, access the ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/hashicorp/vault-helm"}),"documentation"),"."),Object(o.b)("h3",{id:"keycloak"},"Keycloak"),Object(o.b)("p",null,Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/keycloak/keycloak"}),"Keycloak")," is an Open Source Identity and Access Management solution for modern Applications and Services."),Object(o.b)("h4",{id:"implementation-6"},"Implementation"),Object(o.b)("p",null,"By default the ",Object(o.b)("strong",{parentName:"p"},"Keycloak")," is disabled in ",Object(o.b)("em",{parentName:"p"},"VKPR")," installation. An example of configuration:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-yaml"}),"keycloak:\n  enabled: true\n  keycloak:\n    username: keycloak\n    password: admin123\n")),Object(o.b)("p",null,"To view more configuration, access the ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/codecentric/helm-charts/tree/master/charts/keycloak#configuration"}),"documentation"),"."),Object(o.b)("h2",{id:"backup-stack"},"Backup stack"),Object(o.b)("h3",{id:"velero"},"Velero"),Object(o.b)("p",null,Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/vmware-tanzu/velero"}),"Velero")," gives you tools to back up and restore your Kubernetes cluster resources and persistent volumes."),Object(o.b)("h4",{id:"implementation-7"},"Implementation"),Object(o.b)("p",null,"By default ",Object(o.b)("strong",{parentName:"p"},"Velero")," is disabled in ",Object(o.b)("em",{parentName:"p"},"VKPR")," installation. An example of configuration:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-yaml"}),"velero:\n  enabled: true\n  initContainers: \n    - name: velero-plugin-for-aws\n      image: velero/velero-plugin-for-aws:v1.0.0\n      imagePullPolicy: IfNotPresent\n      volumeMounts:\n        - mountPath: /target\n          name: plugins\n")),Object(o.b)("p",null,"To see more configurations, access the ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/vmware-tanzu/helm-charts/tree/main/charts/velero"}),"documentation"),"."))}b.isMDXComponent=!0},94:function(e,t,a){"use strict";a.d(t,"a",(function(){return p})),a.d(t,"b",(function(){return d}));var n=a(0),r=a.n(n);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function c(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=r.a.createContext({}),b=function(e){var t=r.a.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):c(c({},t),e)),a},p=function(e){var t=b(e.components);return r.a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},m=r.a.forwardRef((function(e,t){var a=e.components,n=e.mdxType,o=e.originalType,s=e.parentName,l=i(e,["components","mdxType","originalType","parentName"]),p=b(a),m=n,d=p["".concat(s,".").concat(m)]||p[m]||u[m]||o;return a?r.a.createElement(d,c(c({ref:t},l),{},{components:a})):r.a.createElement(d,c({ref:t},l))}));function d(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=a.length,s=new Array(o);s[0]=m;var c={};for(var i in t)hasOwnProperty.call(t,i)&&(c[i]=t[i]);c.originalType=e,c.mdxType="string"==typeof e?e:n,s[1]=c;for(var l=2;l<o;l++)s[l]=a[l];return r.a.createElement.apply(null,s)}return r.a.createElement.apply(null,a)}m.displayName="MDXCreateElement"}}]);